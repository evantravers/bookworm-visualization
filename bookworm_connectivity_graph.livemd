# Bookworm Connectivity Graph

```elixir
Mix.install([
  {:req, "~> 0.3.0"},
  {:floki, "~> 0.34.0"},
  {:kino_explorer, "~> 0.1.4"},
  {:libgraph, "~> 0.16.0"}
])
```

## ðŸ¤” Why?

[Bookworm](https://bookworm.fm/) is one of my favorite podcasts. Like many listeners I use it as a filter to find quality books to add to my queue. I love how the hosts don't just read but engage with the material, holding each other accountable with takeaways and challenges.

A recurring joke in Bookworm is how many times they refer to [Ep. 42, How To Read a Book by Mortimer Adler](https://bookworm.fm/42/). The last few times they've made that jokeâ€¦Â I've wanted to actually visualize thatâ€¦Â graph. I know Mike loves Obsidian, I love Elixir and have been learning Livebookâ€¦Â let's play!

## ðŸŽ£ Scraping

The first thing is to scrape the pages for processing and evaluation. One lovely thing about Livebook is that if you structure each code block separately, it intelligently memoizes each variable and only re-evaluates them if the structure changes.

Previously, I had used [HTTPoison](https://github.com/edgurgel/httpoison) to do some downloading, but my friend [Seth](http://megalithic.io) has recommended [Req](https://github.com/wojtekmach/req), so let's give that a whirl.

Adding the following to the setup:

<!-- livebook:{"force_markdown":true} -->

```elixir
Mix.install([
  {:req, "~> 0.3.0"}
])
```

Now I can see if I can hit the opening page:

```elixir
Req.get!("https://bookworm.fm/").body
```

Success! Let's be a little more intentional.

Bookworm's website is structured logically. Every episode will be in the form `https://bookworm.fm/1/` up to `https://bookworm.fm/<current>/`. The most recent post is the top `<h2>` on the page.

Adding the [req_easyhtml](https://github.com/wojtekmach/req_easyhtml) plugin to dependencies.

<!-- livebook:{"break_markdown":true} -->

Now I can hone the CSS selector I need to get the most current link. What's really nice (again) about Livebook is that as I rerun the code over and overâ€¦Â I'm not pummeling my internet friends' server with requests. Livebook's cells have localized and memoized all the variables.

```elixir
most_recent_episode_number =
  Req.get!(url: "https://bookworm.fm/").body
  |> Floki.parse_document!()
  |> Floki.find("h2 a")
  |> List.first()
  |> Floki.attribute("href")
  |> List.first()
  |> String.split("/", trim: true)
  |> List.last()
  |> String.to_integer()
```

â˜ï¸ This is a super gross way to do this, but I can fix it later.

Anyway. Excelsior!

```elixir
raw_episodes =
  Enum.map(1..most_recent_episode_number, fn num ->
    url = "https://bookworm.fm/#{num}/"

    %{
      # going to be important later! (basically the private key for the episode)
      url: url,
      request: Req.get!(url: url)
    }
  end)
```

The first time I tried this, I forgot the trailing slash at the end of the URL and was getting tons of redirects (I'm guessing to the URI with the trailing slash.) ðŸ¤·

Let's do some cleanup on thisâ€¦Â we don't care about all the html, just the bit inside the main area.

```elixir
episodes =
  raw_episodes
  |> Enum.map(fn %{request: request} = episode ->
    floki_article =
      request.body
      |> Floki.parse_fragment!()
      |> Floki.find("article")

    links =
      floki_article
      |> Floki.find("a")
      |> Enum.map(fn link ->
        link
        |> Floki.attribute("href")
        |> List.first()
      end)

    episode
    |> Map.put(:floki_article, floki_article)
    |> Map.put(:article, Floki.text(floki_article, sep: " "))
    |> Map.put(:links, links)
  end)
```

Everytime I create one of these tiny blocks, it feels wrong to my DRY-trained programming brain, but I know from experience with Livebooks that it rewards little iterative steps.

I've thought of a several different things I want to do with this:

* a table of "most linked to episodes"
* a graph showing all the links
* transformation to markdown notes that could be stuck in someone's (*cough* Mike *cough*) Obsidian.

Let's go!

## ðŸ—ºï¸ Graphs and Maps

I thought that the first thing I'm going to need to do is to transform this list of raw bodies into something that we can actually work with and display as a table.

I started to add a Smart Cell Data Explorer, which will automatically add dependencies for all it's plugins and thingsâ€¦Â but I'm running into it freaking out over the EasyHTML/Floki structs... let's go for the throat and try the graph.

I've done this before for [Advent of Code](https://adventofcode.com), so excuse the magicâ€¦Â ðŸ§™

```elixir
graph =
  episodes
  |> Enum.reduce(Graph.new(), fn episode, g ->
    episode
    |> Map.get(:links)
    |> Enum.reduce(g, fn link, g ->
      Graph.add_edge(g, Map.get(episode, :url), link)
    end)
  end)
```

Hey presto, we have a graph!

But now we need to display itâ€¦ the naive way!

```elixir
dot_output = elem(Graph.to_dot(graph), 1)

IO.puts(dot_output)
```

Ordinarily we could paste that into something like [Graphviz Online](https://dreampuf.github.io/GraphvizOnline) and we'd be done, but we've exceeded the limits.

Let's output a file for safekeeping.

```elixir
File.write!("#{__DIR__}/output.dot", dot_output)
```

## References

* https://hexdocs.pm/floki/Floki.html
* https://hexdocs.pm/libgraph/Graph.html
* https://dev.to/zorbash/a-livebook-smart-cell-to-render-diagrams-fpm
* https://kroki.io/
